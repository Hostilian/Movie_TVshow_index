================================================================================
          COPY-PASTE READY QUERIES FOR DBS PORTAL
          Categories: A, F2, CN, D1N - All Requirements Met
================================================================================

================================================================================
D1 (Categories: A F2)
================================================================================
NATURAL LANGUAGE:
List all movies together with their director names by joining the movie and director tables so we can see who directed each film sorted by year.

RA:
π(movie_id, title, year, name)(MOVIE <* DIRECTOR)

SQL:
SELECT m.movie_id, m.title, m.year, d.name AS director_name
FROM movie AS m
JOIN director AS d ON m.director_id = d.director_id
ORDER BY m.year;

================================================================================
D2 (Categories: A F2)
================================================================================
NATURAL LANGUAGE:
Find all actors who appeared in the movie titled Inception by joining actor and movie_actor tables to see the complete cast with their role types.

RA:
π(actor_id, name, role_type)(σ(title = 'Inception')(ACTOR <* MOVIE_ACTOR <* MOVIE))

SQL:
SELECT a.actor_id, a.name, ma.role_type
FROM actor AS a
JOIN movie_actor AS ma ON a.actor_id = ma.actor_id
JOIN movie AS m ON ma.movie_id = m.movie_id
WHERE m.title = 'Inception';

================================================================================
D3 (Categories: A F2)
================================================================================
NATURAL LANGUAGE:
Show all movies that belong to the Action genre by joining movie, movie_genre and genre tables to filter action films sorted by their IMDb rating.

RA:
π(movie_id, title, year, imdb_rating)(σ(genre_name = 'Action')(MOVIE <* MOVIE_GENRE <* GENRE))

SQL:
SELECT m.movie_id, m.title, m.year, m.imdb_rating
FROM movie AS m
JOIN movie_genre AS mg ON m.movie_id = mg.movie_id
JOIN genre AS g ON mg.genre_id = g.genre_id
WHERE g.genre_name = 'Action'
ORDER BY m.imdb_rating DESC;

================================================================================
D4 (Categories: A F2)
================================================================================
NATURAL LANGUAGE:
List all user reviews for movies directed by Christopher Nolan by joining user_rating, movie and director tables to see audience feedback on his films.

RA:
π(title, user_name, rating_value, review_text)(σ(name = 'Christopher Nolan')(USER_RATING <* MOVIE <* DIRECTOR))

SQL:
SELECT m.title, ur.user_name, ur.rating_value, ur.review_text
FROM user_rating AS ur
JOIN movie AS m ON ur.movie_id = m.movie_id
JOIN director AS d ON m.director_id = d.director_id
WHERE d.name = 'Christopher Nolan';

================================================================================
D5 (Categories: C N) ← THIS COVERS CN REQUIREMENT!
================================================================================
NATURAL LANGUAGE:
Show all movies with their award information including movies that have never received any awards so the marketing team can identify films needing promotion push.

RA:
π(movie_id, title, year, award_name, is_winner)(MOVIE ⟕ AWARD)

SQL:
SELECT m.movie_id, m.title, m.year, a.award_name, a.is_winner
FROM movie AS m
LEFT JOIN award AS a ON m.movie_id = a.movie_id;

================================================================================
D6 (Categories: D1 N) ← THIS COVERS D1N REQUIREMENT!
================================================================================
NATURAL LANGUAGE:
List all directors together with their movies including directors who have not yet directed any films in our database so HR can track inactive talent.

RA:
π(director_id, name, birth_year, movie_id, title, year)(DIRECTOR ⟕ MOVIE)

SQL:
SELECT d.director_id, d.name, d.birth_year, m.movie_id, m.title, m.year
FROM director AS d
LEFT JOIN movie AS m ON d.director_id = m.director_id;

================================================================================
D7 (Categories: A F2)
================================================================================
NATURAL LANGUAGE:
List all awards that were won not just nominated along with movie title using WHERE clause to filter winners and ORDER BY to sort chronologically by year awarded.

RA:
π(award_id, award_name, category, year_awarded, title)(σ(is_winner = TRUE)(AWARD <* MOVIE))

SQL:
SELECT a.award_id, a.award_name, a.category, a.year_awarded, m.title
FROM award AS a
JOIN movie AS m ON a.movie_id = m.movie_id
WHERE a.is_winner = TRUE
ORDER BY a.year_awarded;

================================================================================
D8 (Categories: A F2)
================================================================================
NATURAL LANGUAGE:
Find all lead actors in movies that have an IMDb rating above eight using DISTINCT to avoid duplicates when actors have multiple lead roles in high-rated films.

RA:
π(actor_id, name)(σ(imdb_rating > 8 AND role_type = 'lead')(ACTOR <* MOVIE_ACTOR <* MOVIE))

SQL:
SELECT DISTINCT a.actor_id, a.name
FROM actor AS a
JOIN movie_actor AS ma ON a.actor_id = ma.actor_id
JOIN movie AS m ON ma.movie_id = m.movie_id
WHERE m.imdb_rating > 8 AND ma.role_type = 'lead';

================================================================================
D9 (Categories: C N) ← ALSO COVERS CN REQUIREMENT!
================================================================================
NATURAL LANGUAGE:
Display all genres and show which movies belong to each genre including genres that currently have no movies assigned so content managers can identify gaps in catalog coverage.

RA:
π(genre_id, genre_name, movie_id, title)(GENRE ⟕ MOVIE_GENRE ⟕ MOVIE)

SQL:
SELECT g.genre_id, g.genre_name, m.movie_id, m.title
FROM genre AS g
LEFT JOIN movie_genre AS mg ON g.genre_id = mg.genre_id
LEFT JOIN movie AS m ON mg.movie_id = m.movie_id;

================================================================================
D10 (Categories: D1 N) ← ALSO COVERS D1N REQUIREMENT!
================================================================================
NATURAL LANGUAGE:
Show all actors with their movie appearances including actors who have not been cast in any films yet so casting directors can find available talent for new projects.

RA:
π(actor_id, name, movie_id, role_type)(ACTOR ⟕ MOVIE_ACTOR)

SQL:
SELECT a.actor_id, a.name, ma.movie_id, ma.role_type
FROM actor AS a
LEFT JOIN movie_actor AS ma ON a.actor_id = ma.actor_id;

================================================================================
                    CATEGORY COVERAGE SUMMARY
================================================================================

Categories covered by queries:
- A (Projection): D1, D2, D3, D4, D5, D6, D7, D8, D9, D10
- F2 (Join + Projection): D1, D2, D3, D4, D7, D8
- C (Selection/Projection): D5, D9
- N (Outer Join): D5, D6, D9, D10
- D1 (Two-table Natural Join): D6, D10

Combined categories:
- CN (C + N): D5, D9 ✓
- D1N (D1 + N): D6, D10 ✓

================================================================================
                    LOOP DISCUSSION - COPY TO PORTAL
================================================================================

Copy this text to the Loop Discussion section:

YES - there IS a circular dependency (loop) in the Movie Database schema.

THE LOOP:
The MOVIE table contains a self-referencing foreign key called "sequel_of" 
that points back to movie_id within the same table. This creates a circular 
dependency where MOVIE references itself:

    MOVIE.sequel_of → MOVIE.movie_id

This relationship models movie sequel chains. For example, "The Dark Knight 
Rises" can reference "The Dark Knight" which can reference "Batman Begins", 
forming a franchise chain within the same entity.

WHY THIS LOOP EXISTS:
Movie franchises naturally form sequel relationships. The sequel_of column 
enables queries like finding all sequels to a movie or tracing complete 
franchise histories. This is a legitimate real-world modeling requirement 
for a movie database.

TECHNICAL IMPLICATIONS:
1. Recursive CTEs (WITH RECURSIVE) are needed to traverse sequel chains
2. Original movies must be inserted before their sequels
3. ON DELETE SET NULL prevents orphan references when originals are deleted
4. Application logic must prevent circular chains (Movie A → B → A)

BENEFITS:
Enables franchise analysis, sequel chain traversal, and maintains normalized 
relationships between related movies without requiring a separate table.

================================================================================
                              END OF FILE
================================================================================
