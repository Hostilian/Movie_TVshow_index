================================================================================
       COPY-PASTE READY QUERIES FOR ADVANCED CATEGORIES
       DBS Portal - Movie Database (xozte001)
================================================================================

Instructions:
1. In portal, click "Add category"
2. Select the category from dropdown (B, C, D1, D2, J, or M)
3. Paste the Natural Language description
4. Paste the SQL query
5. Submit

================================================================================
███████████████████████████████████████████████████████████████████████████████
CATEGORY B: NEGATIVE QUERY ON AT LEAST TWO JOINED TABLES
███████████████████████████████████████████████████████████████████████████████
================================================================================

--- B-1 ---
NATURAL:
Find all actors who have NOT appeared in any movies in our database so casting directors can identify available talent without existing film commitments.

SQL:
SELECT a.actor_id, a.name, a.birth_year
FROM actor a
LEFT JOIN movie_actor ma ON a.actor_id = ma.actor_id
WHERE ma.actor_id IS NULL;

--- B-2 ---
NATURAL:
Find all directors who have NOT directed any movie with an IMDb rating above 8.0 so we can identify directors still waiting for their breakthrough hit.

SQL:
SELECT d.director_id, d.name
FROM director d
WHERE NOT EXISTS (
    SELECT 1 FROM movie m
    WHERE m.director_id = d.director_id
    AND m.imdb_rating > 8.0
);

--- B-3 ---
NATURAL:
Find all movies that have NOT received any awards or nominations so the marketing team can identify films needing recognition campaign efforts.

SQL:
SELECT m.movie_id, m.title, m.year, m.imdb_rating
FROM movie m
LEFT JOIN award a ON m.movie_id = a.movie_id
WHERE a.award_id IS NULL;

--- B-4 ---
NATURAL:
Find all genres that have NOT been assigned to any movies in our database so content curators can identify unused genre categories.

SQL:
SELECT g.genre_id, g.genre_name
FROM genre g
LEFT JOIN movie_genre mg ON g.genre_id = mg.genre_id
WHERE mg.genre_id IS NULL;

================================================================================
███████████████████████████████████████████████████████████████████████████████
CATEGORY C: SELECT ONLY THOSE RELATED TO...
███████████████████████████████████████████████████████████████████████████████
================================================================================

--- C-1 ---
NATURAL:
Select only those actors who appeared in movies directed by Christopher Nolan to identify the talent pool he prefers collaborating with repeatedly.

SQL:
SELECT DISTINCT a.actor_id, a.name
FROM actor a
JOIN movie_actor ma ON a.actor_id = ma.actor_id
JOIN movie m ON ma.movie_id = m.movie_id
JOIN director d ON m.director_id = d.director_id
WHERE d.name = 'Christopher Nolan';

--- C-2 ---
NATURAL:
Select only those genres that have movies with IMDb rating above 8.5 to find which genre categories consistently produce the highest quality content.

SQL:
SELECT DISTINCT g.genre_id, g.genre_name
FROM genre g
JOIN movie_genre mg ON g.genre_id = mg.genre_id
JOIN movie m ON mg.movie_id = m.movie_id
WHERE m.imdb_rating > 8.5;

--- C-3 ---
NATURAL:
Select only those studios that have produced movies winning awards to identify the most prestigious production companies in our database.

SQL:
SELECT DISTINCT s.studio_id, s.studio_name
FROM studio s
JOIN movie m ON s.studio_id = m.studio_id
JOIN award a ON m.movie_id = a.movie_id
WHERE a.is_winner = TRUE;

--- C-4 ---
NATURAL:
Select only those countries that have movies produced in them with runtime over 150 minutes to find regions favoring epic length films.

SQL:
SELECT DISTINCT c.country_id, c.country_name
FROM country c
JOIN movie_country mc ON c.country_id = mc.country_id
JOIN movie m ON mc.movie_id = m.movie_id
WHERE m.runtime > 150;

================================================================================
███████████████████████████████████████████████████████████████████████████████
CATEGORY D1: UNIVERSAL QUANTIFICATION (SELECT ALL RELATED TO)
███████████████████████████████████████████████████████████████████████████████
Pattern: Find X that is related to ALL Y (uses double NOT EXISTS)
================================================================================

--- D1-1 ---
NATURAL:
Find actors who have appeared in ALL genres that exist in our database meaning they are truly versatile performers who acted in every single genre category.

SQL:
SELECT a.actor_id, a.name
FROM actor a
WHERE NOT EXISTS (
    SELECT g.genre_id
    FROM genre g
    WHERE NOT EXISTS (
        SELECT 1
        FROM movie_actor ma
        JOIN movie_genre mg ON ma.movie_id = mg.movie_id
        WHERE ma.actor_id = a.actor_id
        AND mg.genre_id = g.genre_id
    )
);

--- D1-2 ---
NATURAL:
Find directors who have directed movies in ALL countries where films have been produced meaning truly international filmmakers with global reach.

SQL:
SELECT d.director_id, d.name
FROM director d
WHERE NOT EXISTS (
    SELECT c.country_id
    FROM country c
    WHERE EXISTS (SELECT 1 FROM movie_country)
    AND NOT EXISTS (
        SELECT 1
        FROM movie m
        JOIN movie_country mc ON m.movie_id = mc.movie_id
        WHERE m.director_id = d.director_id
        AND mc.country_id = c.country_id
    )
);

================================================================================
███████████████████████████████████████████████████████████████████████████████
CATEGORY D2: RESULT CHECK OF D1 QUERY
███████████████████████████████████████████████████████████████████████████████
Purpose: Verify D1 results by showing all relationships
================================================================================

--- D2-1 (Verifies D1-1) ---
NATURAL:
For each actor found in D1 query show all the genres they have acted in to verify they truly appeared in every single genre in our database.

SQL:
SELECT a.name AS actor_name, g.genre_name, COUNT(m.movie_id) AS movie_count
FROM actor a
JOIN movie_actor ma ON a.actor_id = ma.actor_id
JOIN movie m ON ma.movie_id = m.movie_id
JOIN movie_genre mg ON m.movie_id = mg.movie_id
JOIN genre g ON mg.genre_id = g.genre_id
WHERE a.actor_id IN (
    SELECT a2.actor_id
    FROM actor a2
    WHERE NOT EXISTS (
        SELECT g2.genre_id FROM genre g2
        WHERE NOT EXISTS (
            SELECT 1 FROM movie_actor ma2
            JOIN movie_genre mg2 ON ma2.movie_id = mg2.movie_id
            WHERE ma2.actor_id = a2.actor_id AND mg2.genre_id = g2.genre_id
        )
    )
)
GROUP BY a.name, g.genre_name
ORDER BY a.name, g.genre_name;

================================================================================
███████████████████████████████████████████████████████████████████████████████
CATEGORY J: SAME QUERY IN 3 DIFFERENT SQL STATEMENTS
███████████████████████████████████████████████████████████████████████████████
================================================================================

QUERY TASK: Find all movies that have received at least one award

--- J Version 1 (EXISTS) ---
NATURAL:
Find all movies that have received at least one award using EXISTS subquery pattern to identify critically recognized films in our database.

SQL:
SELECT m.movie_id, m.title, m.year
FROM movie m
WHERE EXISTS (
    SELECT 1 FROM award a WHERE a.movie_id = m.movie_id
);

--- J Version 2 (IN) ---
NATURAL:
Find all movies that have received at least one award using IN subquery pattern as an alternative approach to locate award-winning content.

SQL:
SELECT m.movie_id, m.title, m.year
FROM movie m
WHERE m.movie_id IN (
    SELECT a.movie_id FROM award a
);

--- J Version 3 (JOIN) ---
NATURAL:
Find all movies that have received at least one award using JOIN approach with DISTINCT to eliminate duplicates when films have multiple awards.

SQL:
SELECT DISTINCT m.movie_id, m.title, m.year
FROM movie m
JOIN award a ON m.movie_id = a.movie_id;

================================================================================
███████████████████████████████████████████████████████████████████████████████
CATEGORY M: QUERY OVER A VIEW
███████████████████████████████████████████████████████████████████████████████
================================================================================

STEP 1 - First create the view in your database:

CREATE OR REPLACE VIEW movie_details_view AS
SELECT
    m.movie_id,
    m.title,
    m.year,
    m.runtime,
    m.imdb_rating,
    d.name AS director_name,
    s.studio_name
FROM movie m
JOIN director d ON m.director_id = d.director_id
LEFT JOIN studio s ON m.studio_id = s.studio_id;

STEP 2 - Query the view:

--- M-1 ---
NATURAL:
Show all high-rated movies from the movie_details_view including their directors and studios for executive dashboard reports filtering by quality threshold.

SQL:
SELECT *
FROM movie_details_view
WHERE imdb_rating > 8.0
ORDER BY imdb_rating DESC;

--- M-2 ---
NATURAL:
Find movies from movie_details_view where runtime exceeds 150 minutes to identify epic length productions along with their director and studio information.

SQL:
SELECT title, year, runtime, director_name, studio_name
FROM movie_details_view
WHERE runtime > 150
ORDER BY runtime DESC;

================================================================================
                    LOOP DISCUSSION (COPY TO PORTAL)
================================================================================

YES - there IS a circular dependency (loop) in the Movie Database schema.

THE LOOP:
The MOVIE table contains a self-referencing foreign key called "sequel_of"
that points back to movie_id within the same table. This creates a circular
dependency where MOVIE references itself:

    MOVIE.sequel_of → MOVIE.movie_id

This relationship models movie sequel chains. For example, "The Dark Knight
Rises" can reference "The Dark Knight" which can reference "Batman Begins",
forming a franchise chain within the same entity.

WHY THIS LOOP EXISTS:
Movie franchises naturally form sequel relationships. The sequel_of column
enables queries like finding all sequels to a movie or tracing complete
franchise histories. This is a legitimate real-world modeling requirement
for a movie database.

TECHNICAL IMPLICATIONS:
1. Recursive CTEs (WITH RECURSIVE) are needed to traverse sequel chains
2. Original movies must be inserted before their sequels
3. ON DELETE SET NULL prevents orphan references when originals are deleted
4. Application logic must prevent circular chains (Movie A → B → A)

================================================================================
                    QUICK CHECKLIST
================================================================================

☐ Upload Conceptual Schema (06_conceptual_schema.md)
☐ Fill Loop Discussion (copy text above)
☐ Add Category B query (Negative - actors without movies)
☐ Add Category C query (Related to - actors in Nolan films)
☐ Add Category D1 query (Universal - actors in ALL genres)
☐ Add Category D2 query (D1 verification)
☐ Add Category J queries (Same query 3 ways - all 3 versions)
☐ Add Category M query (View query - need to create view first!)

================================================================================
