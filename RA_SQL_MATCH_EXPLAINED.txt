===============================================================================
WHY RA AND SQL NOW PRODUCE EQUAL RESULTS - TECHNICAL EXPLANATION
===============================================================================

PROBLEM BEFORE:
---------------
The old queries failed portal validation because:
1. RA <* (natural join) returns ALL columns from BOTH tables
2. SQL "SELECT m.title, d.name FROM movie m JOIN director d..." only returns 2 columns
3. Result sets had different column counts = "Results are NOT equal"

SOLUTION APPLIED:
-----------------
Changed all join SQL queries to use:
  SELECT DISTINCT * ... JOIN ... USING (column_name)

WHY USING CLAUSE WORKS:
-----------------------
The USING clause differs from ON clause:

  ON clause:  SELECT * FROM A JOIN B ON A.x = B.x
              Returns: A.x, A.y, B.x, B.z (join column appears TWICE)

  USING:      SELECT * FROM A JOIN B USING (x)
              Returns: x, A.y, B.z (join column appears ONCE)

This matches RA natural join (<*) behavior exactly:
  A <* B
  Returns: x, A.y, B.z (join column appears ONCE)

EXAMPLE WITH YOUR SCHEMA:
-------------------------
MOVIE has: movie_id, title, year, director_id, ...
DIRECTOR has: director_id, name, birth_year, ...

RA:   MOVIE <* DIRECTOR
      Returns: movie_id, title, year, director_id, name, birth_year, ...
      (director_id appears ONCE)

SQL:  SELECT * FROM MOVIE JOIN DIRECTOR USING (director_id)
      Returns: director_id, movie_id, title, year, name, birth_year, ...
      (director_id appears ONCE - column order may differ, but set is equal)

BAD:  SELECT * FROM MOVIE JOIN DIRECTOR ON MOVIE.director_id = DIRECTOR.director_id
      Returns: movie_id, title, year, director_id, director_id, name, birth_year
      (director_id appears TWICE - result NOT equal to RA)

VALID JOIN CHAINS IN YOUR SCHEMA:
---------------------------------
Based on FK paths, these are the ONLY valid <* chains:

Two-table joins:
  MOVIE <* DIRECTOR          (movie.director_id → director.director_id)
  MOVIE <* STUDIO            (movie.studio_id → studio.studio_id)
  STUDIO <* COUNTRY          (studio.country_id → country.country_id)
  USER_RATING <* MOVIE       (user_rating.movie_id → movie.movie_id)
  AWARD <* MOVIE             (award.movie_id → movie.movie_id)
  MOVIE_ACTOR <* ACTOR       (movie_actor.actor_id → actor.actor_id)
  MOVIE_ACTOR <* MOVIE       (movie_actor.movie_id → movie.movie_id)
  MOVIE_GENRE <* GENRE       (movie_genre.genre_id → genre.genre_id)
  MOVIE_GENRE <* MOVIE       (movie_genre.movie_id → movie.movie_id)
  MOVIE_COUNTRY <* COUNTRY   (movie_country.country_id → country.country_id)
  MOVIE_COUNTRY <* MOVIE     (movie_country.movie_id → movie.movie_id)

Three-table chains:
  MOVIE <* MOVIE_ACTOR <* ACTOR          (via movie_id, then actor_id)
  MOVIE <* MOVIE_GENRE <* GENRE          (via movie_id, then genre_id)
  MOVIE <* MOVIE_COUNTRY <* COUNTRY      (via movie_id, then country_id)
  MOVIE <* STUDIO <* COUNTRY             (via studio_id, then country_id)
  USER_RATING <* MOVIE <* DIRECTOR       (via movie_id, then director_id)
  AWARD <* MOVIE <* DIRECTOR             (via movie_id, then director_id)

INVALID CHAIN THAT WAS IN OLD FILE:
-----------------------------------
  MOVIE <* DIRECTOR <* STUDIO <* AWARD

This is INVALID because:
- DIRECTOR table has NO studio_id column
- DIRECTOR cannot join to STUDIO
- The old file had this chain which would fail

CORRECT CHAIN FOR MOVIES → DIRECTORS → THEIR AWARDS:
  AWARD <* MOVIE <* DIRECTOR

This works because:
- AWARD has movie_id → joins to MOVIE
- MOVIE has director_id → joins to DIRECTOR

CATEGORIES EXPLAINED:
---------------------
A = π (projection) - SELECT specific columns only
B = σ (selection) - WHERE clause filters rows
C = π + σ combined - SELECT specific columns WHERE condition
D1 = Two-table natural join (<*)
D2 = Three-table natural join chain
F1 = Join + Selection (WHERE after join)
F2 = Join + Projection (SELECT columns after join)
F3 = Join + Selection + Projection combined
G1 = COUNT aggregation
G2 = AVG/MIN/MAX/SUM aggregations
G3 = GROUP BY
G4 = GROUP BY + HAVING
H1 = UNION (∪)
H2 = INTERSECTION (∩)
H3 = DIFFERENCE (−) = EXCEPT in SQL
I1 = Subquery in WHERE (EXISTS, IN)
I2 = Scalar subquery in SELECT
J = Correlated subquery
K = ORDER BY (τ tau sort operator)
L = DISTINCT (δ delta duplicate elimination)
M = Self-join (table joins itself)
N = Outer join (LEFT JOIN, includes NULLs)
O = Rename (ρ rho) - column aliases
P = Cartesian product (×) = CROSS JOIN

RA OPERATOR SYMBOLS REFERENCE:
------------------------------
π (pi)      = Projection (SELECT columns)
σ (sigma)   = Selection (WHERE clause)
<*          = Natural join (left)
*>          = Natural join (right)
<*>         = Full natural join
⋈           = Theta join (with condition)
∪           = Union
∩           = Intersection
−           = Difference
×           = Cartesian product
ρ (rho)     = Rename
γ (gamma)   = Aggregation (GROUP BY)
τ (tau)     = Sort (ORDER BY)
δ (delta)   = Distinct
⟕           = Left outer join
⟖           = Right outer join
⟗           = Full outer join

===============================================================================
