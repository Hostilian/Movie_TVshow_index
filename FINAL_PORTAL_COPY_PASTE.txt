================================================================================
     üé¨ FINAL PORTAL COPY-PASTE GUIDE - ALL 3 ITERATIONS üé¨
     BI-DBS.21 DBS-2025 - xozte001 - Movie Database

     THIS FILE CONTAINS EVERYTHING YOU NEED TO COPY-PASTE
================================================================================

================================================================================
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë    ‚ïö‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïù
                    TITLE AND DESCRIPTION (5 points)
================================================================================

--- TITLE (paste in "Title" field) ---

Movie and TV Database Management System


--- DESCRIPTION (paste in "Description" field) - 285 words ---

This comprehensive database system is designed to manage and organize detailed information about movies and television productions from around the world. The system serves as a centralized repository for film metadata, enabling users to explore relationships between movies, their cast members, directors, genres, and production details.

The primary purpose of this database is to support a movie information platform similar to IMDb, providing functionality for movie discovery, cast analysis, genre exploration, and ratings aggregation. Users can search for films by various criteria including title, release year, genre, actor, or director. The system tracks many-to-many relationships between movies and actors, as well as movies and genres, reflecting the real-world complexity of film production.

Key features include storage of movie ratings from both IMDb and user-submitted reviews, allowing for comprehensive quality assessment. The database also maintains information about production studios and countries of origin, supporting analysis of international co-productions and studio output patterns.

Data is sourced from the OMDb API (Open Movie Database), which provides reliable, well-structured movie metadata including titles, release dates, runtime, plot summaries, cast lists, and ratings. This ensures the database contains realistic, verifiable information rather than fabricated test data.

The system architecture follows best practices in relational database design, implementing proper normalization to Third Normal Form (3NF), establishing referential integrity through foreign key constraints, and utilizing indexes for query optimization. The design specifically avoids circular dependencies to ensure clean query paths and straightforward data maintenance operations. The database handles complex relationships between directors, actors, studios, genres, countries, awards, and user ratings to provide a complete film information management solution.


================================================================================
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
              CONCEPTUAL SCHEMA + LOOP DISCUSSION (15 points)
================================================================================

--- LOOP DISCUSSION (paste in "Loop discussion" field) ---

YES - there IS a circular dependency (loop) in the Movie Database schema.

THE LOOP:
The MOVIE table contains a self-referencing foreign key called "sequel_of" that points back to movie_id within the same table. This creates a circular dependency where MOVIE references itself:

MOVIE.sequel_of ‚Üí MOVIE.movie_id

This relationship models movie sequel chains. For example, "The Dark Knight Rises" can reference "The Dark Knight" which can reference "Batman Begins", forming a franchise chain within the same entity.

WHY THIS LOOP EXISTS:
Movie franchises naturally form sequel relationships. The sequel_of column enables queries like finding all sequels to a movie or tracing complete franchise histories. This is a legitimate real-world modeling requirement for a movie database.

TECHNICAL IMPLICATIONS:
1. Recursive CTEs (WITH RECURSIVE) are needed to traverse sequel chains
2. Original movies must be inserted before their sequels
3. ON DELETE SET NULL prevents orphan references when originals are deleted
4. Application logic must prevent circular chains (Movie A ‚Üí B ‚Üí A)

BENEFITS:
Enables franchise analysis, sequel chain traversal, and maintains normalized relationships between related movies without requiring a separate table.

--- 8 PRIMARY ENTITIES (for the Conceptual Schema) ---

1. DIRECTOR - Film directors with name and birth year
2. ACTOR - Film actors with name and birth year
3. GENRE - Film genre categories (Action, Comedy, etc.)
4. COUNTRY - Countries for production origins
5. STUDIO - Production studios/companies
6. MOVIE - Central entity - core movie information
7. USER_RATING - User-submitted ratings and reviews
8. AWARD - Awards and nominations received

3 BINDING ENTITIES (M:N relationships):
- MOVIE_ACTOR (movies ‚Üî actors)
- MOVIE_GENRE (movies ‚Üî genres)
- MOVIE_COUNTRY (movies ‚Üî countries)


================================================================================
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    QUERIES (30 points) - 25 Natural + 25 SQL + 10 RA
================================================================================

IMPORTANT: Each query needs:
- Natural language description (100+ characters)
- SQL query (must return valid results)
- RA query (for 10 queries minimum)

================================================================================
                    QUERIES D1-D10 (COVER: CN, D1N categories)
================================================================================

--- QUERY D1 (Categories: A, F2) ---

NATURAL:
List all movies together with their director names by joining the movie and director tables so we can see who directed each film sorted by release year in descending order.

SQL:
SELECT m.movie_id, m.title, m.year, d.name AS director_name
FROM movie AS m
JOIN director AS d ON m.director_id = d.director_id
ORDER BY m.year DESC;

RA:
œÄ(movie_id, title, year, name)(MOVIE ‚ãà DIRECTOR)


--- QUERY D2 (Categories: A, F2, F3) ---

NATURAL:
Find all actors who appeared in the movie titled Inception by joining actor and movie_actor tables to see the complete cast list with their corresponding role types.

SQL:
SELECT a.actor_id, a.name, ma.role_type
FROM actor AS a
JOIN movie_actor AS ma ON a.actor_id = ma.actor_id
JOIN movie AS m ON ma.movie_id = m.movie_id
WHERE m.title = 'Inception';

RA:
œÄ(actor_id, name, role_type)(œÉ(title = 'Inception')(ACTOR ‚ãà MOVIE_ACTOR ‚ãà MOVIE))


--- QUERY D3 (Categories: A, F2, F3) ---

NATURAL:
Show all movies that belong to the Action genre by joining movie, movie_genre and genre tables to filter action films sorted by their IMDb rating in descending order.

SQL:
SELECT m.movie_id, m.title, m.year, m.imdb_rating
FROM movie AS m
JOIN movie_genre AS mg ON m.movie_id = mg.movie_id
JOIN genre AS g ON mg.genre_id = g.genre_id
WHERE g.genre_name = 'Action'
ORDER BY m.imdb_rating DESC;

RA:
œÄ(movie_id, title, year, imdb_rating)(œÉ(genre_name = 'Action')(MOVIE ‚ãà MOVIE_GENRE ‚ãà GENRE))


--- QUERY D4 (Categories: A, F2, F3) ---

NATURAL:
List all user reviews for movies directed by Christopher Nolan by joining user_rating, movie and director tables to see all audience feedback on films directed by this acclaimed filmmaker.

SQL:
SELECT m.title, ur.user_name, ur.rating_value, ur.review_text
FROM user_rating AS ur
JOIN movie AS m ON ur.movie_id = m.movie_id
JOIN director AS d ON m.director_id = d.director_id
WHERE d.name = 'Christopher Nolan';

RA:
œÄ(title, user_name, rating_value, review_text)(œÉ(name = 'Christopher Nolan')(USER_RATING ‚ãà MOVIE ‚ãà DIRECTOR))


--- QUERY D5 (Categories: C, N) ‚Üê COVERS CN! ---

NATURAL:
Show all movies with their award information including movies that have never received any awards so the marketing team can identify films needing promotion push and award campaign efforts.

SQL:
SELECT m.movie_id, m.title, m.year, a.award_name, a.is_winner
FROM movie AS m
LEFT JOIN award AS a ON m.movie_id = a.movie_id;

RA:
œÄ(movie_id, title, year, award_name, is_winner)(MOVIE ‚üï AWARD)


--- QUERY D6 (Categories: D1, N) ‚Üê COVERS D1N! ---

NATURAL:
List all directors together with their movies including directors who have not yet directed any films in our database so human resources can track inactive talent and contract opportunities.

SQL:
SELECT d.director_id, d.name, d.birth_year, m.movie_id, m.title, m.year
FROM director AS d
LEFT JOIN movie AS m ON d.director_id = m.director_id;

RA:
œÄ(director_id, name, birth_year, movie_id, title, year)(DIRECTOR ‚üï MOVIE)


--- QUERY D7 (Categories: A, F2, F3) ---

NATURAL:
List all awards that were won not just nominated along with movie title using WHERE clause to filter only winners and ORDER BY to sort chronologically by year the award was received.

SQL:
SELECT a.award_id, a.award_name, a.category, a.year_awarded, m.title
FROM award AS a
JOIN movie AS m ON a.movie_id = m.movie_id
WHERE a.is_winner = TRUE
ORDER BY a.year_awarded;

RA:
œÄ(award_id, award_name, category, year_awarded, title)(œÉ(is_winner = TRUE)(AWARD ‚ãà MOVIE))


--- QUERY D8 (Categories: A, F2, F3, L) ---

NATURAL:
Find all lead actors in movies that have an IMDb rating above eight using DISTINCT to avoid duplicates when actors have multiple lead roles in highly rated critically acclaimed films.

SQL:
SELECT DISTINCT a.actor_id, a.name
FROM actor AS a
JOIN movie_actor AS ma ON a.actor_id = ma.actor_id
JOIN movie AS m ON ma.movie_id = m.movie_id
WHERE m.imdb_rating > 8 AND ma.role_type = 'lead';

RA:
œÄ(actor_id, name)(œÉ(imdb_rating > 8 ‚àß role_type = 'lead')(ACTOR ‚ãà MOVIE_ACTOR ‚ãà MOVIE))


--- QUERY D9 (Categories: C, N) ‚Üê COVERS CN! ---

NATURAL:
Display all genres and show which movies belong to each genre including genres that currently have no movies assigned so content managers can identify gaps in catalog coverage needing attention.

SQL:
SELECT g.genre_id, g.genre_name, m.movie_id, m.title
FROM genre AS g
LEFT JOIN movie_genre AS mg ON g.genre_id = mg.genre_id
LEFT JOIN movie AS m ON mg.movie_id = m.movie_id;

RA:
œÄ(genre_id, genre_name, movie_id, title)(GENRE ‚üï MOVIE_GENRE ‚üï MOVIE)


--- QUERY D10 (Categories: D1, N) ‚Üê COVERS D1N! ---

NATURAL:
Show all actors with their movie appearances including actors who have not been cast in any films yet so casting directors can find available talent for new upcoming film projects.

SQL:
SELECT a.actor_id, a.name, ma.movie_id, ma.role_type
FROM actor AS a
LEFT JOIN movie_actor AS ma ON a.actor_id = ma.actor_id;

RA:
œÄ(actor_id, name, movie_id, role_type)(ACTOR ‚üï MOVIE_ACTOR)


================================================================================
                    QUERIES D11-D25 (REMAINING CATEGORIES)
================================================================================

--- QUERY D11 (Category: B - Selection) ---

NATURAL:
Find all movies released after the year 2010 to analyze recent film trends and identify which modern productions have achieved high ratings and commercial success in theaters worldwide.

SQL:
SELECT *
FROM movie
WHERE year > 2010;

RA:
œÉ(year > 2010)(MOVIE)


--- QUERY D12 (Category: B - Selection) ---

NATURAL:
Find all actors born before 1970 who represent the veteran generation of performers and have established long successful careers in the film industry spanning multiple decades of work.

SQL:
SELECT *
FROM actor
WHERE birth_year < 1970;

RA:
œÉ(birth_year < 1970)(ACTOR)


--- QUERY D13 (Category: B - Selection) ---

NATURAL:
Find all movies with an IMDb rating greater than 8.5 which represents the highest tier of critically acclaimed films that have achieved near-universal praise from audiences and critics alike.

SQL:
SELECT *
FROM movie
WHERE imdb_rating > 8.5;

RA:
œÉ(imdb_rating > 8.5)(MOVIE)


--- QUERY D14 (Category: G1 - COUNT) ---

NATURAL:
Count the total number of movies in our database to get an overview of the catalog size and understand the scale of our film collection for inventory and reporting purposes.

SQL:
SELECT COUNT(*) AS total_movies
FROM movie;


--- QUERY D15 (Category: G2 - AVG/MIN/MAX) ---

NATURAL:
Calculate the average IMDb rating across all movies in the database to establish a baseline quality metric and understand the overall caliber of films in our collection.

SQL:
SELECT ROUND(AVG(imdb_rating), 2) AS average_rating
FROM movie;


--- QUERY D16 (Category: G3 - GROUP BY) ---

NATURAL:
Count the number of movies each director has made in our database grouped by director to identify the most prolific filmmakers and analyze their output frequency over time.

SQL:
SELECT d.name AS director_name, COUNT(m.movie_id) AS movie_count
FROM director AS d
LEFT JOIN movie AS m ON d.director_id = m.director_id
GROUP BY d.director_id, d.name
ORDER BY movie_count DESC;


--- QUERY D17 (Category: G4 - GROUP BY + HAVING) ---

NATURAL:
Find genres that have an average movie rating above 7.5 to identify which film categories consistently deliver high quality productions that resonate with audiences and critics.

SQL:
SELECT g.genre_name, ROUND(AVG(m.imdb_rating), 2) AS avg_rating
FROM genre AS g
JOIN movie_genre AS mg ON g.genre_id = mg.genre_id
JOIN movie AS m ON mg.movie_id = m.movie_id
GROUP BY g.genre_id, g.genre_name
HAVING AVG(m.imdb_rating) > 7.5
ORDER BY avg_rating DESC;


--- QUERY D18 (Category: H1 - UNION) ---

NATURAL:
Get all unique names from both director and actor tables combined using UNION to create a comprehensive list of all talent in the film industry represented in our database.

SQL:
SELECT name FROM director
UNION
SELECT name FROM actor;


--- QUERY D19 (Category: H2 - INTERSECT) ---

NATURAL:
Find movies that belong to both Action AND Sci-Fi genres simultaneously by using INTERSECT to identify films that combine explosive action with futuristic science fiction elements.

SQL:
SELECT movie_id FROM movie_genre
JOIN genre USING (genre_id)
WHERE genre_name = 'Action'
INTERSECT
SELECT movie_id FROM movie_genre
JOIN genre USING (genre_id)
WHERE genre_name = 'Sci-Fi';


--- QUERY D20 (Category: H3 - EXCEPT/DIFFERENCE) ---

NATURAL:
Find directors in our database who have not directed any movies yet using EXCEPT to identify talent that exists in our records but has no associated film productions listed.

SQL:
SELECT director_id FROM director
EXCEPT
SELECT director_id FROM movie;

RA:
œÄ(director_id)(DIRECTOR) - œÄ(director_id)(MOVIE)


--- QUERY D21 (Category: I1 - EXISTS/IN Subquery) ---

NATURAL:
Find all movies that have received at least one award nomination or win by using EXISTS to filter only films that appear in the awards table regardless of winner status.

SQL:
SELECT *
FROM movie
WHERE EXISTS (SELECT 1 FROM award WHERE award.movie_id = movie.movie_id);


--- QUERY D22 (Category: I2 - Scalar Subquery) ---

NATURAL:
Show each movie title alongside the count of actors who appeared in it using a scalar subquery to display cast size information without requiring explicit grouping operations.

SQL:
SELECT title,
       (SELECT COUNT(*) FROM movie_actor WHERE movie_actor.movie_id = movie.movie_id) AS actor_count
FROM movie;


--- QUERY D23 (Category: J - Correlated Subquery) ---

NATURAL:
Find movies with ratings higher than the average rating of all movies from the same release year to identify films that outperformed their contemporaries in terms of critical reception.

SQL:
SELECT *
FROM movie m1
WHERE imdb_rating > (
    SELECT AVG(imdb_rating)
    FROM movie m2
    WHERE m2.year = m1.year
);


--- QUERY D24 (Category: K - ORDER BY) ---

NATURAL:
Get all movies sorted by IMDb rating in descending order to create a ranked list from highest to lowest rated films allowing users to quickly find the best reviewed productions.

SQL:
SELECT *
FROM movie
ORDER BY imdb_rating DESC;


--- QUERY D25 (Category: M - Self-Join) ---

NATURAL:
Find movie sequels by performing a self-join on the movie table matching sequel_of to movie_id to display pairs of sequel films alongside their original predecessor movies.

SQL:
SELECT m1.title AS sequel_title, m2.title AS original_title
FROM movie m1
JOIN movie m2 ON m1.sequel_of = m2.movie_id;


--- QUERY D26 (Category: O - Rename/Alias) ---

NATURAL:
Display movie information with renamed columns using aliases to provide more user-friendly column names like film_title instead of title for better readability in reports.

SQL:
SELECT title AS film_title, year AS release_year, imdb_rating AS rating
FROM movie;


--- QUERY D27 (Category: P - Cartesian Product) ---

NATURAL:
Create a cartesian product of genre and country tables to generate all possible combinations of genres and countries for analysis of potential international genre distribution patterns.

SQL:
SELECT *
FROM genre
CROSS JOIN country;

RA:
GENRE √ó COUNTRY


--- QUERY D28 (Category: D2 - Three-table Join) ---

NATURAL:
Join movie through movie_actor to actor table using three-table natural join chain to display complete information about which actors appeared in which films with their roles.

SQL:
SELECT *
FROM movie
JOIN movie_actor USING (movie_id)
JOIN actor USING (actor_id);

RA:
MOVIE ‚ãà MOVIE_ACTOR ‚ãà ACTOR


--- QUERY D29 (Category: F1 - Join + Selection) ---

NATURAL:
Get movies with their directors for films released after 2015 combining join operation with selection to filter recent movies while displaying their director information alongside.

SQL:
SELECT *
FROM movie
JOIN director USING (director_id)
WHERE year > 2015;

RA:
œÉ(year > 2015)(MOVIE ‚ãà DIRECTOR)


--- QUERY D30 (Category: A - Projection) ---

NATURAL:
Show only the title and year columns from all movies using projection to extract specific attributes from the movie table for a simplified view of the film catalog.

SQL:
SELECT DISTINCT title, year
FROM movie;

RA:
œÄ(title, year)(MOVIE)


================================================================================
                    REFERENCES (Required for 3rd iteration)
================================================================================

--- REFERENCES (paste in "References" field) ---

1. OMDb API (Open Movie Database) - https://www.omdbapi.com/
   Used for sourcing movie metadata including titles, ratings, and plot summaries.

2. PostgreSQL Documentation - https://www.postgresql.org/docs/
   Reference for SQL syntax and database functions.

3. IMDb - https://www.imdb.com/
   Reference for verifying movie information accuracy.


================================================================================
                    CREATE SCRIPT (Upload 03_create_script.sql)
================================================================================

Your create script file: 03_create_script.sql
- Contains 11 tables (8 primary + 3 binding)
- All constraints defined
- All foreign keys with proper ON DELETE behavior


================================================================================
                    INSERT SCRIPT (Upload 04_insert_script.sql)
================================================================================

Your insert script file: 04_insert_script.sql
- All 11 tables have data
- 15 directors, 30 actors, 12 genres, 10 countries, 10 studios
- 15 movies with all relationships populated
- User ratings and awards included


================================================================================
                    CATEGORY COVERAGE CHECKLIST
================================================================================

Your 30 queries cover these required categories:

‚úÖ A  - Projection (D1, D2, D3, D4, D7, D8, D30)
‚úÖ B  - Selection (D11, D12, D13)
‚úÖ C  - Selection + Projection (D5, D9) ‚Üê CN covered!
‚úÖ D1 - Two-table Natural Join (D6, D10) ‚Üê D1N covered!
‚úÖ D2 - Three-table Join (D28)
‚úÖ F1 - Join + Selection (D29)
‚úÖ F2 - Join + Projection (D1, D2, D3, D4, D7, D8)
‚úÖ F3 - Join + Selection + Projection (D2, D3, D4, D7, D8)
‚úÖ F4 - Join + Selection + Aggregation (covered via G queries with joins)
‚úÖ F5 - Join + Aggregation + GROUP BY (D16, D17)
‚úÖ G1 - COUNT (D14)
‚úÖ G2 - AVG/MIN/MAX/SUM (D15)
‚úÖ G3 - GROUP BY (D16)
‚úÖ G4 - GROUP BY + HAVING (D17)
‚úÖ H1 - UNION (D18)
‚úÖ H2 - INTERSECT (D19)
‚úÖ H3 - EXCEPT (D20)
‚úÖ I1 - EXISTS/IN Subquery (D21)
‚úÖ I2 - Scalar Subquery (D22)
‚úÖ J  - Correlated Subquery (D23)
‚úÖ K  - ORDER BY (D24)
‚úÖ L  - DISTINCT (D8, D30)
‚úÖ M  - Self-Join (D25)
‚úÖ N  - Outer Join (D5, D6, D9, D10) ‚Üê CN and D1N covered!
‚úÖ O  - Rename (D26)
‚úÖ P  - Cartesian Product (D27)


================================================================================
                    QUICK ACTION CHECKLIST
================================================================================

‚ñ° 1. Go to portal ‚Üí "Title and description" ‚Üí Paste title and description
‚ñ° 2. Go to portal ‚Üí "Conceptual schema" ‚Üí Upload 06_conceptual_schema.md
‚ñ° 3. Go to portal ‚Üí "Loop discussion" ‚Üí Paste loop discussion text
‚ñ° 4. Go to portal ‚Üí "Queries" ‚Üí Add all 30 queries with Natural + SQL + RA
‚ñ° 5. Go to portal ‚Üí "Create script" ‚Üí Upload 03_create_script.sql
‚ñ° 6. Go to portal ‚Üí "Insert script" ‚Üí Upload 04_insert_script.sql
‚ñ° 7. Go to portal ‚Üí "References" ‚Üí Paste references
‚ñ° 8. Click "Check and submission" ‚Üí Verify all requirements pass
‚ñ° 9. Submit each iteration

================================================================================
                    END OF GUIDE - GOOD LUCK! üé¨
================================================================================
